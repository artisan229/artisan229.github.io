---
layout: single
title: "소수 판정"
categories: algorithm
tag: [python, algorithm, math]
toc: true
---
## 소수 판정
이 글에서는 소수 판정에 관한 파이썬 코드를 보여준다.

### 1. 원리
이 글에서 소개하는 소수 판정 알고리즘의 원리는 소수의 정의에서 파생된다.
소수의 정의는 1보다 큰 자연수 중 1과 자기 자신만을 약수로 가지는 수이다.

여기서 소수 N에 대하여 두 가지 조건을 얻을 수 있다.
1) N은 1보다 크다.
2) N은 1과 N으로만 나누어 떨어져야 한다.

위 조건을 바탕으로 소수 판정 함수를 작성한 파이썬 코드는 다음과 같다.

```python
def isPrime(N):
    if N < 1: # 1) N은 1보다 크다.
        return False
    cnt = 0 # N의 약수가 몇개인지 저장하는 변수
    for i in range(1, N + 1):
        if N % i == 0:
            cnt += 1
    if cnt == 2: # 2) N은 1과 N으로만 나누어 떨어져야 한다.
        return True
    else:
        return False
```

### 2. 개선
하지만 위 코드는 몇 가지 개선점이 보인다.

1) 상기한 조건을 적절히 수정하면 함수를 줄일 수 있을 것으로 예상된다.
2) N에 대한 소수 판정이 수행될 때 O(N)의 시간복잡도를 가지지만, 1~N과 같이 범위가 주어진 문제 상황에서는 O(N²)의 시간복잡도를 가진다.

이런 개선점을 개선한 코드는 다음과 같다.
우선 코드량에 대한 개선을 먼저 진행했다.

```python
def isPrime(N):
    if N < 1: # 1) N은 1보다 크다.
        return False
    for i in range(2, N):
        if N % i == 0: # 2-개선) 1과 N 이외의 수로 나누어 떨어지면 N은 소수가 아니다.
            return False
    return True
```

다음은 함수의 성능을 개선할 것인데, 성능 개선의 원리는 판정을 위해 탐색하는 수의 범위를 줄이는 것이다.
12을 예로 들면 12의 약수는 1, 2, 3, 4, 6, 12이다. 여기서 발견할 수 있는 점은 약수끼리는 짝이 있어서, 굳이 모든 약수를 찾아낼 필요가 없다는 것이다.

그러면 어디까지 탐색해야할까?
약수는 짝이 있어 약수를 정렬시켰을 때 중간값을 일반화하면 된다.
제곱수의 경우를 생각하여 √N까지 탐색을 하면 O(N)에서 O(√N)으로 시간복잡도가 개선된다.

함수의 성능을 개선한 코드는 다음과 같다.

```python
def isPrime(N):
    if N < 1:
        return False
    for i in range(2, int(N**0.5) + 1): # for문의 범위를 2부터 √N까지로 지정한다.
        if N % i == 0:
            return False
    return True
```

### 3. 결론
이렇게 개선된 함수를 통해 소수 판정 문제를 해결할 수 있게 되었다.